{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"MFGX System Overview \u00b6 MFGX is an Automatic Test System (ATS) for manufacturing environments. It is used to execute product test flows and support quality control. The core objective is: recipe-driven workflows (Recipe/TestPlan) + extensible scripts (Scripts) + stable device integration and data traceability (Logging/Traceability) . Quick Index \u00b6 1. Positioning and use cases 2. Key features 3. Terms and core concepts 4. Architecture (layered) 5. OOP design and extension points 6. System requirements 1. Positioning and use cases \u00b6 MFGX is primarily used on production lines and in lab test stations. It supports: Multi-device integration : DUTs, IO cards, CCD cameras, motion controllers, and communication interfaces Recipe/TestPlan workflows : organizing test steps and nodes as a configurable recipe Multi-DUT parallelism and rotary production lines : including multi-station coordination, rotation rhythm, and load/unload pacing 2. Key features \u00b6 Multi-Device Support : controls and tests multiple DUTs (Device Under Test) concurrently. Recipe/TestPlan Workflow : defines nodes and parameters in a tree structure, reducing maintenance costs compared to hard-coded flows. Flexible Script Framework : extends capabilities through Script classes (communication, measurement, judgment, utilities). User-friendly UI : presents test steps and prompts with an intuitive operator flow; supports step-by-step / section execution for debugging and fast issue isolation; can show images/screenshots in the flow (e.g., camera preview, comparison results, error illustrations) to improve adoption and reduce mis-operations. Permission Management : multi-level user roles and operational constraints. Data Logging / Traceability : logs, CSV, images, reports, and backup path strategies. 3. Terms and core concepts \u00b6 Recipe / TestPlan : the flow recipe that defines container and script nodes, parameters, specs, and fail-jump / branching strategies. Script : the smallest functional unit responsible for device communication, measurement, judgment, or utilities (files, strings, waits, comparisons, etc.). Container : the workflow structuring unit responsible for sequence/parallel/retry/conditions/exception routing. DUT : Device Under Test. Typically maps to a device instance plus UI dashboard and test state/data containers. Dashboard : the UI section corresponding to each DUT (TreeView/DataGridView/Log/status lights, etc.). 4. Architecture (layered) \u00b6 MFGX can typically be viewed as a layered stack: UI \u2192 Workflow/Recipe \u2192 Script Engine \u2192 Device Integration \u2192 Data Persistence MFGX System \u251c\u2500\u2500 UI Layer \u2502 \u251c\u2500\u2500 Main window / Login / Recipe management / Dashboard \u2502 \u251c\u2500\u2500 Business Layer \u2502 \u251c\u2500\u2500 RecipeManagement (load/manage recipes) \u2502 \u251c\u2500\u2500 Global / Context (global state, environment, shared resources) \u2502 \u251c\u2500\u2500 DUT_BASE (DUT lifecycle / data / state) \u2502 \u2514\u2500\u2500 RotaryTestController (rotary / multi-station pacing and coordination) \u2502 \u251c\u2500\u2500 Execution Layer \u2502 \u251c\u2500\u2500 Container (flow structures: sequence / parallel / retry / conditions) \u2502 \u2514\u2500\u2500 ScriptBase (script nodes: Pre / Process / Post) \u2502 \u251c\u2500\u2500 Device Layer \u2502 \u251c\u2500\u2500 DUT devices \u2502 \u251c\u2500\u2500 IO devices (DI/DO, Modbus, etc.) \u2502 \u251c\u2500\u2500 CCD cameras (capture, analysis) \u2502 \u2514\u2500\u2500 Motion (motors, positioning, teaching) \u2502 \u2514\u2500\u2500 Data Layer \u251c\u2500\u2500 INI/JSON (configs, environment variables, recipes) \u251c\u2500\u2500 Logs/CSV/Image (records and traceability) \u2514\u2500\u2500 Reports/DB (reports, SQLite, etc.) 5. OOP design and extension points \u00b6 MFGX maintainability and extensibility rely on OOP abstraction / inheritance / composition . 5.1 Core abstractions (base classes / interfaces) \u00b6 DUT_BASE (abstract/base class) Defines common DUT behavior: state, data containers, dashboard binding, and lifecycle (init/start/end/cleanup). ScriptBase (abstract/base class) Defines the common script node framework: parameter access, logging, spec checking, error handling, and the three-stage pattern (Pre/Process/Post). Container (flow-structure classes) Responsible for how to run : sequence, parallelism, retry, branching, fail-jump/exception routing, etc. 5.2 Inheritance: \u201cshared skeleton + project-specific differences\u201d \u00b6 Typical patterns: - Add a new product DUT: class DUT_XXX : DUT_BASE - Add a new functional script: class Script_YYY : ScriptBase Recommendation : keep common rules and guardrails in the base classes, and implement only the differences in derived classes. 5.3 Composition: \u201creplaceable devices/services\u201d \u00b6 Prefer composition to let DUTs/Scripts obtain services: - DUT owns services: CameraService, MotionService, IOService, CommService... - Scripts access services via Context / ServiceLocator / DI Benefit : when hardware or communication methods change, changes are localized within services instead of spreading across DUTs/Scripts. 5.4 Typical relationships \u00b6 Recipe/TestPlan \u2514\u2500 Container (sequence/parallel/conditions) \u2514\u2500 ScriptBase (framework) \u2514\u2500 Script_xxx (project/device implementations) DUT_BASE (lifecycle / data / state) \u251c\u2500 Dashboard (UI) \u2514\u2500 Services/Devices (Camera/IO/Motion/Comm...) 5.5 How to extend the system \u00b6 Add a DUT : inherit DUT_BASE , implement connection/init/data/UI binding. Add a Script : inherit ScriptBase , implement test logic and spec judgment. Add workflow structures : extend/configure Container (parallelism, retries, fail-jump logic). Add device integrations : encapsulate communications/operations in Services/Adapters. Extension principle : \u201crecipe-driven + modular scripts + decoupled devices\u201d enables safe feature growth. 6. System requirements \u00b6 6.1 Software \u00b6 Operating System : Windows 7 or later .NET Framework : .NET Framework 4.7.2 (or newer depending on the project) 6.2 Hardware (baseline recommendation) \u00b6 CPU : Intel Core i3 or higher RAM : 4GB or more (higher recommended for imaging / multi-DUT) Disk : at least 1GB (adjust based on logs/images volume) Display : 1280\u00d7720 or higher Peripherals : based on station requirements (IO cards, cameras, motor controllers, barcode scanners, etc.)","title":"Home"},{"location":"index.html#mfgx-system-overview","text":"MFGX is an Automatic Test System (ATS) for manufacturing environments. It is used to execute product test flows and support quality control. The core objective is: recipe-driven workflows (Recipe/TestPlan) + extensible scripts (Scripts) + stable device integration and data traceability (Logging/Traceability) .","title":"MFGX System Overview"},{"location":"index.html#quick-index","text":"1. Positioning and use cases 2. Key features 3. Terms and core concepts 4. Architecture (layered) 5. OOP design and extension points 6. System requirements","title":"Quick Index"},{"location":"index.html#1-positioning-and-use-cases","text":"MFGX is primarily used on production lines and in lab test stations. It supports: Multi-device integration : DUTs, IO cards, CCD cameras, motion controllers, and communication interfaces Recipe/TestPlan workflows : organizing test steps and nodes as a configurable recipe Multi-DUT parallelism and rotary production lines : including multi-station coordination, rotation rhythm, and load/unload pacing","title":"1. Positioning and use cases"},{"location":"index.html#2-key-features","text":"Multi-Device Support : controls and tests multiple DUTs (Device Under Test) concurrently. Recipe/TestPlan Workflow : defines nodes and parameters in a tree structure, reducing maintenance costs compared to hard-coded flows. Flexible Script Framework : extends capabilities through Script classes (communication, measurement, judgment, utilities). User-friendly UI : presents test steps and prompts with an intuitive operator flow; supports step-by-step / section execution for debugging and fast issue isolation; can show images/screenshots in the flow (e.g., camera preview, comparison results, error illustrations) to improve adoption and reduce mis-operations. Permission Management : multi-level user roles and operational constraints. Data Logging / Traceability : logs, CSV, images, reports, and backup path strategies.","title":"2. Key features"},{"location":"index.html#3-terms-and-core-concepts","text":"Recipe / TestPlan : the flow recipe that defines container and script nodes, parameters, specs, and fail-jump / branching strategies. Script : the smallest functional unit responsible for device communication, measurement, judgment, or utilities (files, strings, waits, comparisons, etc.). Container : the workflow structuring unit responsible for sequence/parallel/retry/conditions/exception routing. DUT : Device Under Test. Typically maps to a device instance plus UI dashboard and test state/data containers. Dashboard : the UI section corresponding to each DUT (TreeView/DataGridView/Log/status lights, etc.).","title":"3. Terms and core concepts"},{"location":"index.html#4-architecture-layered","text":"MFGX can typically be viewed as a layered stack: UI \u2192 Workflow/Recipe \u2192 Script Engine \u2192 Device Integration \u2192 Data Persistence MFGX System \u251c\u2500\u2500 UI Layer \u2502 \u251c\u2500\u2500 Main window / Login / Recipe management / Dashboard \u2502 \u251c\u2500\u2500 Business Layer \u2502 \u251c\u2500\u2500 RecipeManagement (load/manage recipes) \u2502 \u251c\u2500\u2500 Global / Context (global state, environment, shared resources) \u2502 \u251c\u2500\u2500 DUT_BASE (DUT lifecycle / data / state) \u2502 \u2514\u2500\u2500 RotaryTestController (rotary / multi-station pacing and coordination) \u2502 \u251c\u2500\u2500 Execution Layer \u2502 \u251c\u2500\u2500 Container (flow structures: sequence / parallel / retry / conditions) \u2502 \u2514\u2500\u2500 ScriptBase (script nodes: Pre / Process / Post) \u2502 \u251c\u2500\u2500 Device Layer \u2502 \u251c\u2500\u2500 DUT devices \u2502 \u251c\u2500\u2500 IO devices (DI/DO, Modbus, etc.) \u2502 \u251c\u2500\u2500 CCD cameras (capture, analysis) \u2502 \u2514\u2500\u2500 Motion (motors, positioning, teaching) \u2502 \u2514\u2500\u2500 Data Layer \u251c\u2500\u2500 INI/JSON (configs, environment variables, recipes) \u251c\u2500\u2500 Logs/CSV/Image (records and traceability) \u2514\u2500\u2500 Reports/DB (reports, SQLite, etc.)","title":"4. Architecture (layered)"},{"location":"index.html#5-oop-design-and-extension-points","text":"MFGX maintainability and extensibility rely on OOP abstraction / inheritance / composition .","title":"5. OOP design and extension points"},{"location":"index.html#51-core-abstractions-base-classes-interfaces","text":"DUT_BASE (abstract/base class) Defines common DUT behavior: state, data containers, dashboard binding, and lifecycle (init/start/end/cleanup). ScriptBase (abstract/base class) Defines the common script node framework: parameter access, logging, spec checking, error handling, and the three-stage pattern (Pre/Process/Post). Container (flow-structure classes) Responsible for how to run : sequence, parallelism, retry, branching, fail-jump/exception routing, etc.","title":"5.1 Core abstractions (base classes / interfaces)"},{"location":"index.html#52-inheritance-shared-skeleton-project-specific-differences","text":"Typical patterns: - Add a new product DUT: class DUT_XXX : DUT_BASE - Add a new functional script: class Script_YYY : ScriptBase Recommendation : keep common rules and guardrails in the base classes, and implement only the differences in derived classes.","title":"5.2 Inheritance: \u201cshared skeleton + project-specific differences\u201d"},{"location":"index.html#53-composition-replaceable-devicesservices","text":"Prefer composition to let DUTs/Scripts obtain services: - DUT owns services: CameraService, MotionService, IOService, CommService... - Scripts access services via Context / ServiceLocator / DI Benefit : when hardware or communication methods change, changes are localized within services instead of spreading across DUTs/Scripts.","title":"5.3 Composition: \u201creplaceable devices/services\u201d"},{"location":"index.html#54-typical-relationships","text":"Recipe/TestPlan \u2514\u2500 Container (sequence/parallel/conditions) \u2514\u2500 ScriptBase (framework) \u2514\u2500 Script_xxx (project/device implementations) DUT_BASE (lifecycle / data / state) \u251c\u2500 Dashboard (UI) \u2514\u2500 Services/Devices (Camera/IO/Motion/Comm...)","title":"5.4 Typical relationships"},{"location":"index.html#55-how-to-extend-the-system","text":"Add a DUT : inherit DUT_BASE , implement connection/init/data/UI binding. Add a Script : inherit ScriptBase , implement test logic and spec judgment. Add workflow structures : extend/configure Container (parallelism, retries, fail-jump logic). Add device integrations : encapsulate communications/operations in Services/Adapters. Extension principle : \u201crecipe-driven + modular scripts + decoupled devices\u201d enables safe feature growth.","title":"5.5 How to extend the system"},{"location":"index.html#6-system-requirements","text":"","title":"6. System requirements"},{"location":"index.html#61-software","text":"Operating System : Windows 7 or later .NET Framework : .NET Framework 4.7.2 (or newer depending on the project)","title":"6.1 Software"},{"location":"index.html#62-hardware-baseline-recommendation","text":"CPU : Intel Core i3 or higher RAM : 4GB or more (higher recommended for imaging / multi-DUT) Disk : at least 1GB (adjust based on logs/images volume) Display : 1280\u00d7720 or higher Peripherals : based on station requirements (IO cards, cameras, motor controllers, barcode scanners, etc.)","title":"6.2 Hardware (baseline recommendation)"},{"location":"ConfigEditor.html","text":"Environment Variable Settings \u00b6 1. Add a DUT object and open the editor \u00b6 In the DUT object's property list, locate the EnvirVariable field and click the \"\u2026\" button on the right. This will directly open the Variable Editor window (multi-line editing UI). After opening, you will see content similar to an INI file: multiple sections split by [Section] , and each line defines a Key=Value entry. 2. Format rules (INI style) \u00b6 Sections : written as [SectionName] , e.g., [UI] , [Path] . Key-value pairs : one setting per line, in the form Key=Value . Variable substitution : you can use %VarName% inside strings (e.g., %ProjectName% ), which will be substituted at runtime. Path recommendation : for Windows paths, avoid illegal characters \\ / : * ? \" < > | (especially in file-name templates). 3. Common sections and key descriptions \u00b6 Key Purpose (details) ProductSN Defines SN/barcode format rules. Under [SerialNumber] , you can define multiple SN formats, and the system generates the SN input TextBox on the main UI based on the configuration. When scanning or manually entering an SN, the system first validates it against the configured Regex; invalid formats can block flow entry or prompt an error. Example: ^[A-Z0-9]{12}$ (12 upper-case alphanumeric) TreeShow Controls whether the left TreeView (workflow tree) is displayed on the main UI. If operators only need to press Start and do not need workflow details, you can hide it to simplify the UI and reduce mis-operations. TitleBarcodeShow Controls whether the title bar shows the Barcode/SN information area. If the shop floor already displays SN elsewhere or you want to reduce title bar content, disable it to increase usable screen space. Common values: 0/1 SignalLightShow Controls whether to display the tri-color signal light (or status light) UI. Often used for quick station state recognition (RUN / PASS / FAIL / ALARM). If no signal light is used on-site, disable it. Common values: 0/1 TitleShow Controls whether the entire title bar area is displayed (including version, recipe name, etc.). Disable it if the screen is small or you want a cleaner UI. Common values: 0/1 RunMode Sets the system run mode (project-defined), affecting how flows start, button availability, and runtime behavior. Example: 0 = triggered by the SN TextBox; 1 = triggered by the Start button and supports loop testing; 2 = rotary mode (illustrative). BackupFolder Sets the backup path (supports substitution variables). After the test completes, logs/CSV/images will be backed up to this folder. In multi-station/multi-fixture environments, include Project/Station/Fixture to avoid file mixing. Usually both local and server paths are configured. Example: C:\\Camera\\%ProjectName%\\%StationName%\\%FixtureName% LogFileName Naming template for logs/CSV/images, etc. Typically includes SN, project, station, fixture, and timestamps to ensure uniqueness and traceability. Example: %ProductSN%_%ProjectName%_%StationName%_%FixtureName%_%FixturePart%_%NowTimeHHmmss% 4. Example template \u00b6 [SerialNumber] ProductSN=[A-Z0-9]{12} MAC=[A-Z0-9]{2}:[A-Z0-9]{2}:[A-Z0-9]{2}:[A-Z0-9]{2}:[A-Z0-9]{2}:[A-Z0-9]{2} [UI] TreeShow=1 TitleBarcodeShow=0 SignalLightShow=0 TitleShow=1 RunMode=0 [Path] BackupFolder=C:\\Camera\\%ProjectName%\\%StationName%\\%FixtureName% BackupFolder2=Z:\\Camera\\%ProjectName%\\%StationName%\\%FixtureName% [Common] LogFileName=%ProductSN%_%ProjectName%_%StationName%_%FixtureName%_%FixturePart%_%NowTimeHHmmss% FixturePort=J01 LogUseItemCode=0","title":"Config Editor"},{"location":"ConfigEditor.html#script-and-envir","text":"","title":"Environment Variable Settings"},{"location":"ConfigEditor.html#envir-editor","text":"In the DUT object's property list, locate the EnvirVariable field and click the \"\u2026\" button on the right. This will directly open the Variable Editor window (multi-line editing UI). After opening, you will see content similar to an INI file: multiple sections split by [Section] , and each line defines a Key=Value entry.","title":"1. Add a DUT object and open the editor"},{"location":"ConfigEditor.html#envir-ini-rules","text":"Sections : written as [SectionName] , e.g., [UI] , [Path] . Key-value pairs : one setting per line, in the form Key=Value . Variable substitution : you can use %VarName% inside strings (e.g., %ProjectName% ), which will be substituted at runtime. Path recommendation : for Windows paths, avoid illegal characters \\ / : * ? \" < > | (especially in file-name templates).","title":"2. Format rules (INI style)"},{"location":"ConfigEditor.html#envir-common-keys","text":"Key Purpose (details) ProductSN Defines SN/barcode format rules. Under [SerialNumber] , you can define multiple SN formats, and the system generates the SN input TextBox on the main UI based on the configuration. When scanning or manually entering an SN, the system first validates it against the configured Regex; invalid formats can block flow entry or prompt an error. Example: ^[A-Z0-9]{12}$ (12 upper-case alphanumeric) TreeShow Controls whether the left TreeView (workflow tree) is displayed on the main UI. If operators only need to press Start and do not need workflow details, you can hide it to simplify the UI and reduce mis-operations. TitleBarcodeShow Controls whether the title bar shows the Barcode/SN information area. If the shop floor already displays SN elsewhere or you want to reduce title bar content, disable it to increase usable screen space. Common values: 0/1 SignalLightShow Controls whether to display the tri-color signal light (or status light) UI. Often used for quick station state recognition (RUN / PASS / FAIL / ALARM). If no signal light is used on-site, disable it. Common values: 0/1 TitleShow Controls whether the entire title bar area is displayed (including version, recipe name, etc.). Disable it if the screen is small or you want a cleaner UI. Common values: 0/1 RunMode Sets the system run mode (project-defined), affecting how flows start, button availability, and runtime behavior. Example: 0 = triggered by the SN TextBox; 1 = triggered by the Start button and supports loop testing; 2 = rotary mode (illustrative). BackupFolder Sets the backup path (supports substitution variables). After the test completes, logs/CSV/images will be backed up to this folder. In multi-station/multi-fixture environments, include Project/Station/Fixture to avoid file mixing. Usually both local and server paths are configured. Example: C:\\Camera\\%ProjectName%\\%StationName%\\%FixtureName% LogFileName Naming template for logs/CSV/images, etc. Typically includes SN, project, station, fixture, and timestamps to ensure uniqueness and traceability. Example: %ProductSN%_%ProjectName%_%StationName%_%FixtureName%_%FixturePart%_%NowTimeHHmmss%","title":"3. Common sections and key descriptions"},{"location":"ConfigEditor.html#envir-template","text":"[SerialNumber] ProductSN=[A-Z0-9]{12} MAC=[A-Z0-9]{2}:[A-Z0-9]{2}:[A-Z0-9]{2}:[A-Z0-9]{2}:[A-Z0-9]{2}:[A-Z0-9]{2} [UI] TreeShow=1 TitleBarcodeShow=0 SignalLightShow=0 TitleShow=1 RunMode=0 [Path] BackupFolder=C:\\Camera\\%ProjectName%\\%StationName%\\%FixtureName% BackupFolder2=Z:\\Camera\\%ProjectName%\\%StationName%\\%FixtureName% [Common] LogFileName=%ProductSN%_%ProjectName%_%StationName%_%FixtureName%_%FixturePart%_%NowTimeHHmmss% FixturePort=J01 LogUseItemCode=0","title":"4. Example template"},{"location":"CreateScript.html","text":"Creating Scripts and Setting Environment Variables \u00b6 1. Create a new script (initial parameters) \u00b6 When you click New in Configure (recipe management) to create a new test script flow, the system first opens the Initial Parameter Editor . This is used to define the basic identity of the flow (Project / Mode / Station / Fixture / Version, etc.). 2. Field description \u00b6 Field Description Example Project Project name, usually mapped to the product project VO0301 Mode Script usage mode PROD / ENG / GRR Station Station (test station) PCBA01 Fixture Fixture ID (use J01/J02... for multiple fixtures in the same station) J01 Version Script version for identifying updates V0.0.0.1 Memo Notes (optional) e.g., precautions, change points 3. Versioning and variable usage (% variables) \u00b6 After the script flow is created, during execution the system automatically builds a set of variables that can be referenced inside the workflow based on flow settings and environment variables. These variables are commonly used for: file names paths communication commands logging contents Common syntax: %VariableName% , for example: %ProjectName% %StationName% %FixtureName% %Version% %ProductSN%","title":"Create Script"},{"location":"CreateScript.html#script-and-envir","text":"","title":"Creating Scripts and Setting Environment Variables"},{"location":"CreateScript.html#create-script","text":"When you click New in Configure (recipe management) to create a new test script flow, the system first opens the Initial Parameter Editor . This is used to define the basic identity of the flow (Project / Mode / Station / Fixture / Version, etc.).","title":"1. Create a new script (initial parameters)"},{"location":"CreateScript.html#create-script-fields","text":"Field Description Example Project Project name, usually mapped to the product project VO0301 Mode Script usage mode PROD / ENG / GRR Station Station (test station) PCBA01 Fixture Fixture ID (use J01/J02... for multiple fixtures in the same station) J01 Version Script version for identifying updates V0.0.0.1 Memo Notes (optional) e.g., precautions, change points","title":"2. Field description"},{"location":"CreateScript.html#create-script-vars","text":"After the script flow is created, during execution the system automatically builds a set of variables that can be referenced inside the workflow based on flow settings and environment variables. These variables are commonly used for: file names paths communication commands logging contents Common syntax: %VariableName% , for example: %ProjectName% %StationName% %FixtureName% %Version% %ProductSN%","title":"3. Versioning and variable usage (% variables)"}]}