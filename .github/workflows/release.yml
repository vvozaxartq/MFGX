
name: AutoTestSystem - Release (net472)

on:
  push:
    tags:
      - "v*"
      - "V*"
  workflow_dispatch:

permissions:
  contents: write
  discussions: write  # 需要 Discussions 發文權限

env:
  SOLUTION_FILE: AutoTestSystem.sln
  BUILD_CONFIGURATION: Release
  BUILD_PLATFORM: "Any CPU"
  DISCUSSION_CATEGORY_NAME: "Announcements"

jobs:
  build_and_release:
    runs-on: windows-2022

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Setup NuGet
        uses: NuGet/setup-nuget@v2

      - name: Restore NuGet packages
        shell: pwsh
        run: nuget restore "${{ env.SOLUTION_FILE }}" -NonInteractive

      # ====== Tag 版本寫入 AssemblyInfo.cs（只在 tag 觸發時執行）======
      - name: Stamp version from tag (AssemblyVersion / FileVersion)
        if: startsWith(github.ref, 'refs/tags/')
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # 支援 v / V 開頭，且必須是 4 碼數字版本：v3.0.0.6
          $ver = "${{ github.ref_name }}" -replace '^[vV]', ''
          if ($ver -notmatch '^\d+\.\d+\.\d+\.\d+$') {
            throw "Tag 版本必須是 4 碼：v3.0.0.6 這種格式。你目前是：${{ github.ref_name }}"
          }

          $asm = "AutoTestSystem\Properties\AssemblyInfo.cs"
          if (-not (Test-Path $asm)) {
            throw "找不到 $asm（請確認 AssemblyInfo.cs 路徑）"
          }

          $c = Get-Content $asm -Raw

          if ($c -notmatch 'AssemblyVersion\(\".*?\"\)') {
            throw "$asm 內找不到 [assembly: AssemblyVersion(""..."")]"
          }
          if ($c -notmatch 'AssemblyFileVersion\(\".*?\"\)') {
            throw "$asm 內找不到 [assembly: AssemblyFileVersion(""..."")]"
          }

          $c = [regex]::Replace($c, 'AssemblyVersion\(\".*?\"\)', "AssemblyVersion(`"$ver`")")
          $c = [regex]::Replace($c, 'AssemblyFileVersion\(\".*?\"\)', "AssemblyFileVersion(`"$ver`")")

          Set-Content -Path $asm -Value $c -Encoding UTF8
          Write-Host "Stamped AssemblyVersion / AssemblyFileVersion => $ver"

      - name: Build (Release)
        shell: pwsh
        run: msbuild "${{ env.SOLUTION_FILE }}" /m /p:Configuration="${{ env.BUILD_CONFIGURATION }}" /p:Platform="${{ env.BUILD_PLATFORM }}"

      - name: Package (zip)
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          # 1) 在整個 repo 內找 AutoTestSystem.exe
          $exe = Get-ChildItem -Path . -Recurse -File -Filter "AutoTestSystem.exe" -ErrorAction SilentlyContinue `
            | Where-Object { $_.FullName -notmatch "\\obj\\|\\\.vs\\|\\packages\\|\\TestResults\\|\\bin\\Debug\\" } `
            | Sort-Object LastWriteTime -Descending `
            | Select-Object -First 1

          if (-not $exe) {
            Write-Host "=== 找不到 AutoTestSystem.exe，列出所有 bin 目錄供診斷 ==="
            Get-ChildItem -Path . -Recurse -Directory -ErrorAction SilentlyContinue `
              | Where-Object { $_.FullName -match "\\bin\\" } `
              | Select-Object -First 50 FullName
            throw "找不到 AutoTestSystem.exe。請先確認 Build step 是否真的有產生 exe（或 AssemblyName 是否不同）。"
          }

          $srcDir = Split-Path $exe.FullName -Parent
          Write-Host "Packaging from: $srcDir"
          Write-Host "EXE: $($exe.FullName)"

          # 2) 複製輸出資料夾到 dist
          if (Test-Path dist) { Remove-Item dist -Recurse -Force }
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          Copy-Item -Recurse -Force "$srcDir\*" dist\

          # 3) 產生 zip
          $zipName = "AutoTestSystem-${{ github.ref_name }}.zip"
          if (Test-Path $zipName) { Remove-Item $zipName -Force }
          Compress-Archive -Path dist\* -DestinationPath $zipName -Force
          Write-Host "Created: $zipName"


      - name: Resolve previous tag & build Full Changelog link
        if: startsWith(github.ref, 'refs/tags/')
        id: prev
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $current = "${{ github.ref_name }}"

          # 取所有 tag（以版本排序，最新在前）
          $all = git tag --sort=-v:refname

          # 取第一個「不是當前」的 tag 當作 previousTag
          $previous = $null
          foreach ($t in $all) {
            if ($t -ne $current) { $previous = $t; break }
          }

          if ($previous) {
            "previous=$previous" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            $compare = "${{ github.server_url }}/${{ github.repository }}/compare/$previous...$current"
            "compareUrl=$compare" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            # 第一次發版沒有 previousTag，退而用 commits 連結
            "previous=" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            $commits = "${{ github.server_url }}/${{ github.repository }}/commits/$current"
            "compareUrl=$commits" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

      - name: Compose Release body (Full Changelog)
        if: startsWith(github.ref, 'refs/tags/')
        id: compose_body
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $current = "${{ github.ref_name }}"
          $previous = "${{ steps.prev.outputs.previous }}"
          $url = "${{ steps.prev.outputs.compareUrl }}"


          if ([string]::IsNullOrWhiteSpace($previous)) {
            # 第一次發版：顯示所有提交到當前版本的連結
            $md = "**Full Changelog:** All commits up to $current"
          } else {
            $md = "**Full Changelog:** $previous...$current"
          }


          # 你也可以在這裡加上想要的摘要段落
          # $md = "### Summary`n- ...`n`n" + $md

          "body=$md" | Out-File -FilePath $env:GITHUB_OUTPUT -Append


      # 產生「Commits」清單（Markdown），附加到 body

      - name: Append commits list to body
        if: startsWith(github.ref, 'refs/tags/')
        id: commits_md
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $current = "${{ github.ref_name }}"
          $previous = "${{ steps.prev.outputs.previous }}"
          $repoUrl = "${{ github.server_url }}/${{ github.repository }}"

          # 取得 commit 區間
          if ([string]::IsNullOrWhiteSpace($previous)) {
            $range = $current
            $rangeDesc = "All commits up to $current"
          } else {
            $range = "$previous..$current"
            $rangeDesc = "$previous...$current"
          }

          # 取出 commits：hash、author、email、timestamp、subject（單行）
          $commits = git log $range --no-merges --format="%H%n%an%n%ae%n%at%n%s"
          if (-not $commits) {
            $md = "`n### Commits`n`n_（No commits found in $rangeDesc）_"
          } else {
            $lines = $commits -split "`n"
            $items = @()
            for ($i = 0; $i -lt $lines.Count; $i += 5) {
              $hash = $lines[$i]
              if (-not $hash) { continue }
              $short = $hash.Substring(0,[Math]::Min(7,$hash.Length))
              $author = $lines[$i+1]
              $ts     = [long]$lines[$i+3]
              $subject= $lines[$i+4]

              $date = [DateTimeOffset]::FromUnixTimeSeconds($ts).ToString("yyyy-MM-dd HH:mm")
              $url  = "$repoUrl/commit/$hash"

              # 每條：- **feat: release** `abcdef0` — Author (YYYY-MM-DD HH:mm)
              $items += "- **$subject** `$short` — $author ($date)"
            }

            $md = "`n### Commits`n`n" + ($items -join "`n")
          }

          # 取上一個步驟（Compose Release body）的內容並附加 Commits 清單
          $prevBody = "${{ steps.compose_body.outputs.body }}"
          $final = $prevBody + "`n`n" + $md

          # ⚠️ 以「多行輸出」寫入 $GITHUB_OUTPUT，避免 Invalid format
          Add-Content -Path $env:GITHUB_OUTPUT -Value "body<<BODY"
          Add-Content -Path $env:GITHUB_OUTPUT -Value $final
          Add-Content -Path $env:GITHUB_OUTPUT -Value "BODY"



      - name: Create GitHub Release + upload asset
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          files: AutoTestSystem-${{ github.ref_name }}.zip
          #body: ${{ steps.compose_body.outputs.body }}
          generate_release_notes: true
          #append_body: true

      # =========================
      # ✅ Release 後建立 Discussion 公告
      # =========================

      - name: Resolve Discussion Category ID
        if: startsWith(github.ref, 'refs/tags/')
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = "Stop"

          $ownerRepo = "${{ github.repository }}"
          $parts = $ownerRepo.Split("/")
          $owner = $parts[0]
          $repo  = $parts[1]
          $catName = "${{ env.DISCUSSION_CATEGORY_NAME }}"

          $query = @'
          query($owner:String!, $name:String!){
            repository(owner:$owner, name:$name){
              id
              discussionCategories(first:25){
                nodes { id name }
              }
            }
          }
          '@

          $json = gh api graphql -f query="$query" -f owner="$owner" -f name="$repo" | ConvertFrom-Json

          $repoId = $json.data.repository.id
          if (-not $repoId) { throw "查不到 repository.id，請確認 repo 是否啟用 Discussions。" }

          $cat = $json.data.repository.discussionCategories.nodes | Where-Object { $_.name -eq $catName } | Select-Object -First 1
          if (-not $cat) {
            $all = ($json.data.repository.discussionCategories.nodes | ForEach-Object { $_.name }) -join ", "
            throw "找不到 Discussion Category: '$catName'。目前可用分類：$all"
          }

          "REPO_ID=$repoId" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "CAT_ID=$($cat.id)" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "Resolved repoId=$repoId, categoryId=$($cat.id)"

      - name: Create Discussion announcement
        if: startsWith(github.ref, 'refs/tags/')
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $ErrorActionPreference = "Stop"

          $tag = "${{ github.ref_name }}"
          $releaseUrl = "${{ github.server_url }}/${{ github.repository }}/releases/tag/$tag"
          $assetName = "AutoTestSystem-$tag.zip"

          $title = "Release $tag 已發布 ✅"
          $body = "已自動發佈新版本：**$tag**`n`n- Release 連結：$releaseUrl`n- Assets：$assetName`n`n（此公告由 GitHub Actions 自動建立）"

          $mutation = @'
          mutation($repo:ID!, $cat:ID!, $title:String!, $body:String!){
            createDiscussion(input:{
              repositoryId:$repo,
              categoryId:$cat,
              title:$title,
              body:$body
            }){
              discussion { id url }
            }
          }
          '@

          $result = gh api graphql -f query="$mutation" -f repo="$env:REPO_ID" -f cat="$env:CAT_ID" -f title="$title" -f body="$body"
          Write-Host "Discussion created: $result"

      # =========================
      # ✅ Teams Workflows Webhook Debug（放在 steps 內）
      # =========================


      - name: Notify Teams (Workflows Webhook)
        if: startsWith(github.ref, 'refs/tags/')
        shell: pwsh
        env:
          TEAMS_WEBHOOK: ${{ secrets.TEAMS_WORKFLOW_WEBHOOK_URL }}
        run: |
          $tag = "${{ github.ref_name }}"
          $releaseUrl = "${{ github.server_url }}/${{ github.repository }}/releases/tag/$tag"

          # ✅ 方案 1：直接組出「該 tag 的 asset 下載連結」
          # 格式：/releases/download/<tag>/<asset-name>
          $downloadUrl = "${{ github.server_url }}/${{ github.repository }}/releases/download/$tag/AutoTestSystem-$tag.zip"

          # (可選) 印出 host/path 方便 debug，但不印 query
          $u = [uri]$env:TEAMS_WEBHOOK
          Write-Host "Webhook host: $($u.Scheme)://$($u.Host)$($u.AbsolutePath)"

          $payloadObj = @{
            type = "message"
            attachments = @(
              @{
                contentType = "application/vnd.microsoft.card.adaptive"
                content = @{
                  '$schema' = "http://adaptivecards.io/schemas/adaptive-card.json"
                  type = "AdaptiveCard"
                  version = "1.3"
                  body = @(
                    @{
                      type = "TextBlock"
                      size = "Medium"
                      weight = "Bolder"
                      text = "✅ Release Published: $tag"
                      wrap = $true
                    },
                    @{
                      type = "TextBlock"
                      # 讓文字也可點（Markdown）
                      text = "🔗 Open Release"
                      wrap = $true
                    }
                  )
                  actions = @(
                    @{
                      type  = "Action.OpenUrl"
                      title = "Open Release"
                      url   = $releaseUrl
                    },
                    @{
                      type  = "Action.OpenUrl"
                      title = "Download ZIP"
                      url   = $downloadUrl
                    }
                  )
                }
              }
            )
          }

          $payload = $payloadObj | ConvertTo-Json -Depth 20 -Compress

          try {
            $resp = Invoke-WebRequest -Method Post -Uri $env:TEAMS_WEBHOOK -ContentType "application/json" -Body $payload
            Write-Host "HTTP StatusCode = $($resp.StatusCode)"
            if ($resp.Content) { Write-Host "Response body: $($resp.Content)" }
          } catch {
            Write-Host "Request failed: $($_.Exception.Message)"
            if ($_.Exception.Response -and $_.Exception.Response.StatusCode) {
              Write-Host "HTTP StatusCode = $([int]$_.Exception.Response.StatusCode)"
            }
            throw
          }



